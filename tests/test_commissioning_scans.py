from ophyd.sim import motor1, motor2, det1
import numpy as np
import pytest
from scipy.stats import skewnorm
from ophyd import Signal
from bluesky import RunEngine
from os import path, environ
import numpy as np
from typing import Literal
from scipy.special import comb
import os
import uuid


motor1.delay = 0

class SimCameraStats(Signal):
    """Simulates gaussian intensity data as generated by area detector (such as mean, total, etc)"""
    def __init__(self, name: str, distribution: Literal["gaussian", "smooth_step"], flip: bool=False):
        super().__init__(name=name, )
        self.x = np.linspace(-10, 10, 10)
        self.counter = 0
        if distribution == "gaussian":
            self.intensity = self._sim_intensity_skew_norm_distribution()
        elif distribution == "smooth_step":
            self.intensity = self._sim_intensity_smooth_step(N=5, flip=flip)


    def get(self):
        offset = 2
        value = 5 * self.intensity[self.counter] + np.random.normal(0, 0.01) + offset
        self.counter += 1
        return value
    
    def _sim_intensity_skew_norm_distribution(self):
        a = 9
        return 100 * skewnorm.pdf(self.x, a, loc=0, scale=3) + 10

    def _sim_intensity_smooth_step(self, x_min=-1, x_max=1, N=1, flip=False):
        x = np.clip((self.x - x_min) / (x_max - x_min), 0, 1)

        result = 0
        for n in range(0, N + 1):
            result += comb(N + n, n) * comb(2 * N + 1, N - n) * (-x) ** n

        result *= x ** (N + 1)
        if flip:
            return np.flipud(result)
        else:
            return result
    
@pytest.fixture()
def temp_dir(tmpdir):
    return tmpdir.mkdir("scans_output")

    

    
@pytest.mark.order("first")
def test_1d_scan_gaussian_distribution(run_engine: RunEngine, temp_dir):
    # Setup
    total = SimCameraStats(name="total", distribution="gaussian")
    mean = SimCameraStats(name="mean", distribution="gaussian")
    # Set env variable before importing the beamline library
    environ["HDF5_OUTPUT_DIRECTORY"] = str(temp_dir)
    from mx3_beamline_library.plans.commissioning.commissioning import Scan1D #noqa
    from mx3_beamline_library.plans.commissioning.stats import ScanStats1D


    hdf5_filename = f"gaussian_{uuid.uuid4().hex}.h5"

    # Execute
    scan_1d = Scan1D(
        [total, mean],
        motor1,
        -1,
        1,
        7,
        hdf5_filename=hdf5_filename,
        calculate_first_derivative=False,
    )
    run_engine(scan_1d.run())

    # Verify
    assert path.exists(path.join(temp_dir, hdf5_filename))
    assert isinstance(scan_1d.statistics, list)
    assert len(scan_1d.statistics) == 2
    assert isinstance(scan_1d.statistics[0], ScanStats1D) 
    assert isinstance(scan_1d.statistics[1], ScanStats1D) 
    assert isinstance(scan_1d.intensity_dict["total"], list)
    assert isinstance(scan_1d.intensity_dict["mean"], list)
    assert isinstance(scan_1d.motor_array, np.ndarray)
    assert list(scan_1d.metadata.keys()) == ['hdf5_filename', 'favourite', 'favourite_description']
    assert isinstance(scan_1d.metadata["hdf5_filename"], str)
    assert isinstance(scan_1d.metadata["favourite"], bool)
    assert isinstance(scan_1d.metadata["favourite_description"], str)

@pytest.mark.order(after="test_1d_scan_gaussian_distribution")
def test_1d_scan_smooth_step_distribution(run_engine: RunEngine, temp_dir):
    # Setup
    total = SimCameraStats(name="total", distribution="smooth_step")
    mean = SimCameraStats(name="mean", distribution="smooth_step")
    environ["HDF5_OUTPUT_DIRECTORY"] = str(temp_dir)
    from mx3_beamline_library.plans.commissioning.commissioning import Scan1D #noqa
    from mx3_beamline_library.plans.commissioning.stats import ScanStats1D # noqa


    hdf5_filename = f"smooth_step_{uuid.uuid4().hex}.h5"

    # Execute
    scan_1d = Scan1D(
        [total, mean],
        motor1,
        -1,
        1,
        7,
        hdf5_filename=hdf5_filename,
        calculate_first_derivative=True,
    )
    run_engine(scan_1d.run())

    # Verify
    assert isinstance(scan_1d.first_derivative, np.ndarray)
    assert isinstance(scan_1d.statistics, list)
    assert len(scan_1d.statistics) == 2
    assert isinstance(scan_1d.statistics[0], ScanStats1D) 
    assert isinstance(scan_1d.statistics[1], ScanStats1D) 

def test_scan_1d_inverted_gaussian(run_engine, temp_dir):
    # Setup
    total = SimCameraStats(name="total", distribution="smooth_step", flip=True)
    mean = SimCameraStats(name="mean", distribution="smooth_step", flip=True)
    environ["HDF5_OUTPUT_DIRECTORY"] = str(temp_dir)
    from mx3_beamline_library.plans.commissioning.commissioning import Scan1D #noqa

    hdf5_filename = f"smooth_step_{uuid.uuid4().hex}.h5"

    # Execute
    scan_1d = Scan1D(
        [total, mean],
        motor1,
        -1,
        1,
        7,
        hdf5_filename=hdf5_filename,
        calculate_first_derivative=True,
    )
    run_engine(scan_1d.run())

    # Verify
    assert scan_1d._flipped_gaussian == True

def test_scan_2d(run_engine, temp_dir):
    environ["HDF5_OUTPUT_DIRECTORY"] = str(temp_dir)
    from mx3_beamline_library.plans.commissioning.commissioning import Scan2D #noqa

    scan_2d = Scan2D(
        detectors=[det1],
        motor_1=motor1,
        initial_position_motor_1=-1,
        final_position_motor_1=100,
        number_of_steps_motor_1=5,
        motor_2=motor2,
        initial_position_motor_2=-1,
        final_position_motor_2=100,
        number_of_steps_motor_2=5,
    )
    run_engine(scan_2d.run())
    assert isinstance(scan_2d.intensity, dict)
    assert isinstance(scan_2d.intensity["det1"], list)
    assert list(scan_2d.metadata.keys()) == ['hdf5_filename', 'favourite', 'favourite_description']
    assert isinstance(scan_2d.metadata["hdf5_filename"], str)
    assert isinstance(scan_2d.metadata["favourite"], bool)
    assert isinstance(scan_2d.metadata["favourite_description"], str)

@pytest.mark.parametrize("motor_limits", [(-11, 5), (-5, 20)])
def test_check_motor_limits_failure(motor_limits):
    from mx3_beamline_library.plans.commissioning.commissioning import _check_motor_limits
    motor1.limits = [-10.0, 10.0]
    with pytest.raises(ValueError):
        _check_motor_limits(motor1, motor_limits[0], motor_limits[1])

@pytest.mark.parametrize("motor_limits", [(-5, 5), (-10, 10)])
def test_check_motor_limits(motor_limits):
    from mx3_beamline_library.plans.commissioning.commissioning import _check_motor_limits

    motor1.limits = [-10.0, 10.0]
    result = _check_motor_limits(motor1, motor_limits[0], motor_limits[1])

    assert result is None




