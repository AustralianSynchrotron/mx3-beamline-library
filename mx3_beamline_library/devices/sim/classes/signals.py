from typing import Literal

import numpy as np
import numpy.typing as npt
from ophyd import Signal
from scipy.special import comb
from scipy.stats import skewnorm


class SimCameraStats(Signal):
    """
    Simulates a Gaussian distribution or a smooth
    step function with gaussian noise. This is useful for simulating statistics
    as generated by area detector's stats plugin during commissioning
    """

    def __init__(
        self,
        name: str,
        distribution: Literal["gaussian", "smooth_step"],
        flip: bool = False,
        x_array: npt.NDArray = None,
    ):
        """
        Parameters
        ----------
        name : str
            The name of the signal
        distribution : Literal[&quot;gaussian&quot;, &quot;smooth_step&quot;]
            The type of distribution to simulate
        flip : bool, optional
            Flip the distribution, by default False
        x_array : npt.NDArray, optional
            The x values to use for the distribution, by default None.
            If None, the default x values will be used, which are
            np.linspace(-10, 10, 10)
        """
        super().__init__(
            name=name,
        )
        if x_array is None:
            self.x = self.x = np.linspace(-10, 10, 10)
        else:
            self.x = x_array

        self.counter = 0
        if distribution == "gaussian":
            self.intensity = self._sim_intensity_skew_norm_distribution(flip=flip)

        elif distribution == "smooth_step":
            self.intensity = self._sim_intensity_smooth_step(N=5, flip=flip)

    def get(self) -> float:
        """
        Gets the simulated intensity and adds Gaussian noise.
        Each time this function is called the counter is incremented
        so that the full distribution is used.

        Returns
        -------
        float
            The simulated intensity
        """
        offset = 2
        value = 5 * self.intensity[self.counter] + np.random.normal(0, 0.01) + offset
        self.counter += 1
        return value

    def _sim_intensity_skew_norm_distribution(self, flip: bool) -> npt.NDArray:
        """_
        Simulate intensity using a skew normal distribution

        Parameters
        ----------
        flip : bool
            Flip the distribution

        Returns
        -------
        npt.NDArray
            The simulated intensity
        """
        a = 9
        if flip:
            return -1 * (100 * skewnorm.pdf(self.x, a, loc=0, scale=3) + 10)
        else:
            return 100 * skewnorm.pdf(self.x, a, loc=0, scale=3) + 10

    def _sim_intensity_smooth_step(self, flip, N=5) -> npt.NDArray:
        """
        Simulate intensity using a smooth step function

        Parameters
        ----------
        N : int, optional
            Determines the smoothness of the step function, by default 5
        flip : bool, optional
            Flip the distribution

        Returns
        -------
        npt.NDArray
            The simulated intensity
        """
        x_min = -1
        x_max = 1
        x = np.clip((self.x - x_min) / (x_max - x_min), 0, 1)

        result = 0
        for n in range(0, N + 1):
            result += comb(N + n, n) * comb(2 * N + 1, N - n) * (-x) ** n

        result *= x ** (N + 1)
        if flip:
            return np.flipud(result)
        else:
            return result
