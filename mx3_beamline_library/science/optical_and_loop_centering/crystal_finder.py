import logging
import time
import warnings
from copy import deepcopy
from typing import Optional

import matplotlib.pyplot as plt
import numpy as np
import numpy.typing as npt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from scipy import optimize
from scipy.ndimage import center_of_mass

from mx3_beamline_library.plans.basic_scans import (
    _calculate_alignment_y_motor_coords,
    _calculate_alignment_z_motor_coords,
    _calculate_sample_x_coords,
    _calculate_sample_y_coords,
)
from mx3_beamline_library.schemas.crystal_finder import (
    CrystalPositions,
    CrystalVolume,
    MaximumNumberOfSpots,
    MotorCoordinates,
)
from mx3_beamline_library.schemas.xray_centering import RasterGridCoordinates

logger = logging.getLogger(__name__)
_stream_handler = logging.StreamHandler()
logging.getLogger(__name__).addHandler(_stream_handler)
logging.getLogger(__name__).setLevel(logging.INFO)


class CrystalFinder:
    """
    Calculates the center of mass of individual crystals in a loop, finds the
    size of each crystal, and determines the vertical distance
    between overlapping crystals.

    Attributes
    ----------
    y_nonzero : npt.NDArray
        Nonzero y coordinates of self.filtered_array
    x_nonzero : npt.NDArray
        Nonzero x coordinates of self.filtered_array
    list_of_island_indices : list[set[tuple[int, int]]]
        A list of a set of indices describing individual islands
    list_of_island_arrays : list[npt.NDArray]
        A list of numpy arrays describing individual islands
    _nonzero_coords : npt.NDArray
        Nonzero coordinate array. This array is for internal use only.
        Values of this array will be deleted during runtime for performance purposes
    """

    def __init__(
        self,
        number_of_spots: npt.NDArray,
        threshold: float,
        grid_scan_motor_coordinates: RasterGridCoordinates = None,
    ) -> None:
        """
        Parameters
        ----------
        number_of_spots : npt.NDArray
            An array containing the number of spots obtained from spotfinding.
            The array's shape should be (n_rows, n_cols)
        threshold : float
            We replace all numbers below this threshold with zeros. The resulting
            arrays is saved as self.filtered_array
        grid_scan_motor_coordinates : RasterGridCoordinates
            A RasterGridCoordinates pydantic model generated by the
            optical_and_ray_centering_plan which contains information about the flat
            and edge raster grids. This is used to map pixel coordinates to motor coordinates,
            by default None. If this parameter is not given, only pixel coordinates are
             calculated

        Returns
        -------
        None
        """
        self.number_of_spots = number_of_spots
        self.filtered_array = np.where(
            self.number_of_spots < threshold, 0, number_of_spots
        )

        self.y_nonzero, self.x_nonzero = np.nonzero(self.filtered_array)

        self.list_of_island_indices: list[set[tuple[int, int]]] = None
        self.list_of_islands: list[npt.NDArray] = None

        self._nonzero_coords = np.array([self.x_nonzero, self.y_nonzero]).transpose()
        logger.info(f"Number of non-zero pixels: {len(self.y_nonzero)}")

        self.grid_scan_motor_coordinates = grid_scan_motor_coordinates
        self.sample_x_coords = None
        self.sample_y_coords = None
        self.alignment_y_coords = None

    def _find_adjacent_pixels(self, pixel: tuple[int, int]) -> set[tuple[int, int]]:
        """
        Finds all adjacent pixels of a single pixel containing values different from zero.
        Once we have calculated all adjacent pixels, we remove them from self._nonzero_coords
        to avoid counting them again.

        Parameters
        ----------
        pixel : tuple[int, int]
            A pixel coordinate

        Returns
        -------
        set[tuple[int, int]]
            A set containing adjacent pixels of a single pixel
        """
        if not len(self._nonzero_coords):
            # We have taken into account all pixels, do nothing
            return set()

        # Distance between pixels
        diff = np.array(pixel) - self._nonzero_coords
        distance_between_pixels = np.sqrt(diff[:, 0] ** 2 + diff[:, 1] ** 2)
        adjacent_args = np.argwhere(distance_between_pixels <= np.sqrt(2)).flatten()

        adjacent_pixels = set()
        for arg in adjacent_args:
            adjacent_pixels.update({tuple(self._nonzero_coords[arg])})

        # Remove pixels we have already considered
        self._nonzero_coords = np.delete(self._nonzero_coords, adjacent_args, axis=0)

        return adjacent_pixels

    def _find_individual_islands(
        self, start_coord: tuple[int, int], number_of_spots: npt.NDArray
    ) -> tuple[npt.NDArray, set[tuple[int, int]]]:
        """
        Finds individual islands

        Parameters
        ----------
        start_coord : tuple[int, int]
            We find an island starting from start_coord
        number_of_spots : npt.NDArray
            An array containing the number of spots

        Returns
        -------
        tuple[npt.NDArray, set[tuple[int, int]]]
            The individual island array, and it's corresponding indices
        """
        adjacent_pixels = self._find_adjacent_pixels(start_coord)
        length = [0, len(adjacent_pixels)]
        adjacent_pixels_list = [set(), deepcopy(adjacent_pixels)]

        while length[-1] - length[-2]:
            non_repeated_pixels = adjacent_pixels_list[-1] - adjacent_pixels_list[-2]
            for coord in non_repeated_pixels:
                adjacent_pixels.update(self._find_adjacent_pixels(coord))
            length.append(len(adjacent_pixels))
            adjacent_pixels_list.append(deepcopy(adjacent_pixels))

        island = np.zeros(number_of_spots.shape)
        for index in adjacent_pixels:
            island[index[1]][index[0]] = number_of_spots[index[1]][index[0]]

        return island, adjacent_pixels

    def _find_all_islands(self) -> None:
        """
        Finds all islands in self.filtered_array. The values of self.list_of_island_indices and
        self.list_of_islands are updated here.

        Returns
        -------
        None
        """
        logger.info("Finding islands...")
        t = time.perf_counter()
        self.list_of_island_indices = []

        island, island_indices = self._find_individual_islands(
            (self.x_nonzero[0], self.y_nonzero[0]), self.filtered_array
        )
        self.list_of_island_indices.append(island_indices.copy())

        self.list_of_islands = [island]
        for coord in self._nonzero_coords:
            if tuple(coord) not in island_indices:
                island_tmp, island_indices_tmp = self._find_individual_islands(
                    coord, self.filtered_array
                )
                self.list_of_island_indices.append(island_indices_tmp.copy())
                island_indices.update(island_indices_tmp)

                self.list_of_islands.append(island_tmp)
        logger.info(
            f"It took {time.perf_counter() - t} [s] to find all "
            f"{len(self.list_of_islands)} islands in the loop"
        )

    def _find_centers_of_mass(self) -> list[tuple[int, int]]:
        """
        Calculates the center of mass of all islands found in self.filtered_array

        Returns
        -------
        list[tuple[int, int]]
            A list containing the center of mass of individual islands
        """
        if self.list_of_islands is None or self.list_of_island_indices is None:
            self._find_all_islands()

        center_of_mass_list = []
        for island in self.list_of_islands:
            y_cm, x_cm = center_of_mass(island)
            center_of_mass_list.append((round(x_cm), round(y_cm)))

        return center_of_mass_list

    def find_crystals(self) -> list[CrystalPositions]:
        """
        Calculates the crystal locations, sizes, and centers of mass in a loop in
        units of pixels. To calculate the height and width of the crystal, we assume
        that the crystal is well approximated by a rectangle.
        If self.grid_scan_motor_coordinates is not None, we additionally calculate
        the motor positions corresponding to the locations of the crystals,
        and their centers of mass.

        Returns
        -------
        list[CrystalPositions]
            A list of CrystalPositions Pydantic models containing information about the
            locations of all crystals as well as their sizes.
        """
        if len(self.x_nonzero) == 0:
            logger.info("No crystals found!")
            return None

        if self.list_of_islands is None or self.list_of_island_indices is None:
            self._find_all_islands()

        list_of_crystal_locations_and_sizes: list[CrystalPositions] = []
        for index in self.list_of_island_indices:
            list_of_crystal_locations_and_sizes.append(self._rectangle_coords(index))

        centers_of_mass = self._find_centers_of_mass()

        for (i, crystal_location) in enumerate(list_of_crystal_locations_and_sizes):
            crystal_location.center_of_mass_pixels = centers_of_mass[i]

        # Convert pixel coordinates to motor coordinates
        if self.grid_scan_motor_coordinates is not None:
            for crystal_location in list_of_crystal_locations_and_sizes:
                if self.grid_scan_motor_coordinates.use_centring_table:
                    crystal_location.center_of_mass_motor_coordinates = MotorCoordinates(
                        sample_x=self.sample_x_coords[
                            crystal_location.center_of_mass_pixels[1],
                            crystal_location.center_of_mass_pixels[0],
                        ],
                        sample_y=self.sample_y_coords[
                            crystal_location.center_of_mass_pixels[1],
                            crystal_location.center_of_mass_pixels[0],
                        ],
                        alignment_y=self.alignment_y_coords[
                            crystal_location.center_of_mass_pixels[1],
                            crystal_location.center_of_mass_pixels[0],
                        ],
                        omega=self.grid_scan_motor_coordinates.omega,
                        alignment_x=self.grid_scan_motor_coordinates.alignment_x_pos,
                        # NOTE: alignment_z doesn't change here, so
                        # initial_pos_alignment_z=final_position_alignment_z
                        alignment_z=self.grid_scan_motor_coordinates.initial_pos_alignment_z,
                    )
                else:
                    crystal_location.center_of_mass_motor_coordinates = MotorCoordinates(
                        alignment_y=self.alignment_y_coords[
                            crystal_location.center_of_mass_pixels[1],
                            crystal_location.center_of_mass_pixels[0],
                        ],
                        alignment_z=self.alignment_z_coords[
                            crystal_location.center_of_mass_pixels[1],
                            crystal_location.center_of_mass_pixels[0],
                        ],
                        sample_x=self.grid_scan_motor_coordinates.initial_pos_sample_x,
                        sample_y=self.grid_scan_motor_coordinates.initial_pos_sample_y,
                        alignment_x=self.grid_scan_motor_coordinates.alignment_x_pos,
                        omega=self.grid_scan_motor_coordinates.omega,
                        plate_translation=self.grid_scan_motor_coordinates.plate_translation,
                    )

                (
                    width_micrometers,
                    heigh_micrometers,
                ) = self._crystal_width_and_height_in_micrometers(crystal_location)
                crystal_location.width_micrometers = width_micrometers
                crystal_location.height_micrometers = heigh_micrometers

        return list_of_crystal_locations_and_sizes

    def _crystal_width_and_height_in_micrometers(
        self,
        crystal_positions: CrystalPositions,
    ) -> tuple[float, float]:
        """
        Calculates the width and height of the crystal in micrometers

        Parameters
        ----------
        crystal_positions : CrystalPositions
            A CrystalPositions pydantic model

        Returns
        -------
        tuple[float, float]
            The width and height in micrometers
        """
        pixels_per_mm_x = (
            self.grid_scan_motor_coordinates.number_of_columns
            / self.grid_scan_motor_coordinates.width_mm
        )
        pixels_per_mm_y = (
            self.grid_scan_motor_coordinates.number_of_rows
            / self.grid_scan_motor_coordinates.height_mm
        )

        width_micrometers = crystal_positions.width / pixels_per_mm_x * 1000
        height_micrometers = crystal_positions.height / pixels_per_mm_y * 1000
        return width_micrometers, height_micrometers

    def find_crystals_and_overlapping_crystal_distances(
        self,
    ) -> tuple[list[CrystalPositions], list[dict[str, int]], MaximumNumberOfSpots]:
        """
        Calculates the distance between all overlapping crystals in a loop in units of
        pixels, the crystal locations, and their corresponding sizes (in pixels). The distance
        between the i-th and j-th overlapping crystal is saved in a key following the format:
        f"distance_{i}_{j}"

        Returns
        -------
        list[dict], list[dict[str, int]]
            A list of dictionaries containing information about the locations of all
            crystals as well as their sizes, and a list of dictionaries describing
            the distance between all overlapping crystals in a loop
        """
        list_of_crystal_locations_and_sizes = self.find_crystals()

        if list_of_crystal_locations_and_sizes is None:
            return None, None, None

        distance_list = []
        for i in range(len(self.list_of_island_indices)):
            for j in range(len(self.list_of_island_indices)):
                if j > i:
                    coords_1 = list_of_crystal_locations_and_sizes[i]
                    coords_2 = list_of_crystal_locations_and_sizes[j]
                    if (coords_2.min_x <= coords_1.min_x <= coords_2.max_x) or (
                        coords_2.min_x <= coords_1.max_x <= coords_2.max_x
                    ):
                        # Note that the -1 is added because we're subtracting indices
                        distance = (
                            min(
                                [
                                    abs(coords_1.max_y - coords_2.min_y),
                                    abs(coords_2.max_y - coords_1.min_y),
                                ]
                            )
                            - 1
                        )
                        distance_list.append({f"distance_{i}_{j}": distance, str(i): j})

        maximum_number_of_spots_position = self.maximum_number_of_spots_location()

        return (
            list_of_crystal_locations_and_sizes,
            distance_list,
            maximum_number_of_spots_position,
        )

    def _rectangle_coords(
        self, island_indices: set[tuple[int, int]]
    ) -> CrystalPositions:
        """
        Fits a crystal with a rectangle given the indices of an island. Based on that
        assumption we calculate the bottom_left and bottom right coordinates of the
        rectangle, its width, height, and minimum and maximum x and y values

        Parameters
        ----------
        island_indices : set[tuple[int, int]]
            Indices of an island

        Returns
        -------
        CrystalPositions
            A CrystalPositions pydantic model
        """

        x_vals = []
        y_vals = []
        for coord in island_indices.copy():
            x_vals.append(coord[0])
            y_vals.append(coord[1])

        min_x = min(x_vals)
        max_x = max(x_vals)
        min_y = min(y_vals)
        max_y = max(y_vals)

        bottom_left = (min_x, max_y)
        top_right = (max_x, min_y)
        width = max_x - min_x
        height = max_y - min_y
        crystal_positions = CrystalPositions(
            bottom_left_pixel_coords=bottom_left,
            top_right_pixel_coords=top_right,
            width=width,
            height=height,
            min_x=min_x,
            max_x=max_x,
            min_y=min_y,
            max_y=max_y,
        )

        if self.grid_scan_motor_coordinates is not None:
            if self.grid_scan_motor_coordinates.use_centring_table:
                (
                    bottom_left_motor_coords,
                    top_right_motor_coords,
                ) = self._calculate_motor_positions_with_centring_table(
                    crystal_positions
                )
            else:
                (
                    bottom_left_motor_coords,
                    top_right_motor_coords,
                ) = self._calculate_motor_positions_with_alignment_table(
                    crystal_positions
                )

            crystal_positions.bottom_left_motor_coordinates = bottom_left_motor_coords
            crystal_positions.top_right_motor_coordinates = top_right_motor_coords

        return crystal_positions

    def _calculate_motor_positions_with_alignment_table(
        self, crystal_positions: CrystalPositions
    ) -> tuple[MotorCoordinates, MotorCoordinates]:
        """
        Calculates the bottom_left_motor_coordinates and top_right_motor_coordinates
        when the alignment table was used during the grid scan. This method
        is only called if self.grid_scan_motor_coordinates is not None.
        This method is used for trays

        Parameters
        ----------
        crystal_positions : CrystalPositions
            A CrystalPositions pydantic model

        Returns
        -------
        tuple[MotorCoordinates, MotorCoordinates]
            The bottom_left_motor_coordinates and top_right_motor_coordinates
        """
        assert (
            not self.grid_scan_motor_coordinates.use_centring_table
        ), "The centring table was used during the scan, not the alignment table"

        self.alignment_z_coords = np.fliplr(
            _calculate_alignment_z_motor_coords(self.grid_scan_motor_coordinates)
        )
        self.alignment_y_coords = (
            self._calculate_crystal_finder_alignment_y_coordinates()
        )

        bottom_left_motor_coordinates = MotorCoordinates(
            alignment_y=self.alignment_y_coords[
                crystal_positions.bottom_left_pixel_coords[1],
                crystal_positions.bottom_left_pixel_coords[0],
            ],
            alignment_z=self.alignment_z_coords[
                crystal_positions.bottom_left_pixel_coords[1],
                crystal_positions.bottom_left_pixel_coords[0],
            ],
            sample_x=self.grid_scan_motor_coordinates.initial_pos_sample_x,
            sample_y=self.grid_scan_motor_coordinates.initial_pos_sample_y,
            alignment_x=self.grid_scan_motor_coordinates.alignment_x_pos,
            omega=self.grid_scan_motor_coordinates.omega,
            plate_translation=self.grid_scan_motor_coordinates.plate_translation,
        )

        top_right_motor_coordinates = MotorCoordinates(
            alignment_y=self.alignment_y_coords[
                crystal_positions.top_right_pixel_coords[1],
                crystal_positions.top_right_pixel_coords[0],
            ],
            alignment_z=self.alignment_z_coords[
                crystal_positions.top_right_pixel_coords[1],
                crystal_positions.top_right_pixel_coords[0],
            ],
            sample_x=self.grid_scan_motor_coordinates.initial_pos_sample_x,
            sample_y=self.grid_scan_motor_coordinates.initial_pos_sample_y,
            alignment_x=self.grid_scan_motor_coordinates.alignment_x_pos,
            omega=self.grid_scan_motor_coordinates.omega,
            plate_translation=self.grid_scan_motor_coordinates.plate_translation,
        )
        return bottom_left_motor_coordinates, top_right_motor_coordinates

    def _calculate_motor_positions_with_centring_table(
        self, crystal_positions: CrystalPositions
    ) -> tuple[MotorCoordinates, MotorCoordinates]:
        """
        Calculates the bottom_left_motor_coordinates and top_right_motor_coordinates
        when the centring table was used during the grid scan. This method
        is only called if self.grid_scan_motor_coordinates is not None.
        This method is used for loops

        Parameters
        ----------
        crystal_positions : CrystalPositions
            A CrystalPositions pydantic model

        Returns
        -------
        tuple[MotorCoordinates, MotorCoordinates]
            The bottom_left_motor_coordinates and top_right_motor_coordinates
        """
        # TODO: Add all coordinates to the results
        assert (
            self.grid_scan_motor_coordinates.use_centring_table
        ), "The alignment table was used during the scan, not the centring table"

        self.sample_x_coords = np.fliplr(
            _calculate_sample_x_coords(self.grid_scan_motor_coordinates)
        )
        self.sample_y_coords = np.fliplr(
            _calculate_sample_y_coords(self.grid_scan_motor_coordinates)
        )
        self.alignment_y_coords = (
            self._calculate_crystal_finder_alignment_y_coordinates()
        )

        bottom_left_motor_coordinates = MotorCoordinates(
            sample_x=self.sample_x_coords[
                crystal_positions.bottom_left_pixel_coords[1],
                crystal_positions.bottom_left_pixel_coords[0],
            ],
            sample_y=self.sample_y_coords[
                crystal_positions.bottom_left_pixel_coords[1],
                crystal_positions.bottom_left_pixel_coords[0],
            ],
            alignment_y=self.alignment_y_coords[
                crystal_positions.bottom_left_pixel_coords[1],
                crystal_positions.bottom_left_pixel_coords[0],
            ],
            omega=self.grid_scan_motor_coordinates.omega,
            alignment_x=self.grid_scan_motor_coordinates.alignment_x_pos,
            # NOTE: alignment_z doesn't change here, so
            # initial_pos_alignment_z=final_position_alignment_z
            alignment_z=self.grid_scan_motor_coordinates.initial_pos_alignment_z,
        )

        top_right_motor_coordinates = MotorCoordinates(
            sample_x=self.sample_x_coords[
                crystal_positions.top_right_pixel_coords[1],
                crystal_positions.top_right_pixel_coords[0],
            ],
            sample_y=self.sample_y_coords[
                crystal_positions.top_right_pixel_coords[1],
                crystal_positions.top_right_pixel_coords[0],
            ],
            alignment_y=self.alignment_y_coords[
                crystal_positions.top_right_pixel_coords[1],
                crystal_positions.top_right_pixel_coords[0],
            ],
            omega=self.grid_scan_motor_coordinates.omega,
            alignment_x=self.grid_scan_motor_coordinates.alignment_x_pos,
            # NOTE: alignment_z doesn't change here, so
            # initial_pos_alignment_z=final_position_alignment_z
            alignment_z=self.grid_scan_motor_coordinates.initial_pos_alignment_z,
        )
        return bottom_left_motor_coordinates, top_right_motor_coordinates

    def _calculate_crystal_finder_alignment_y_coordinates(self) -> npt.NDArray:
        """
        Calculates the alignment y motor coordinates from spotfinder data

        Returns
        -------
        npt.NDArray
            The alignment y motor coordinates
        """
        _alignment_y_coords = np.fliplr(
            _calculate_alignment_y_motor_coords(self.grid_scan_motor_coordinates)
        )
        alignment_y_coords = np.zeros(_alignment_y_coords.shape)
        if self.grid_scan_motor_coordinates.number_of_columns % 2 == 0:
            for i in range(_alignment_y_coords.shape[1]):
                if i % 2:
                    alignment_y_coords[:, i] = _alignment_y_coords[:, i]
                else:
                    alignment_y_coords[:, i] = np.flipud(_alignment_y_coords[:, i])
        else:
            for i in range(_alignment_y_coords.shape[1]):
                if i % 2:
                    alignment_y_coords[:, i] = np.flipud(_alignment_y_coords[:, i])
                else:
                    alignment_y_coords[:, i] = _alignment_y_coords[:, i]
        return alignment_y_coords

    def maximum_number_of_spots_location(self) -> MaximumNumberOfSpots | None:
        """
        Finds the maximum number of spots positions (x, y) in the array.
        If self.grid_scan_motor_coordinates  is not None, we additionally
        calculate the motor positions associated the with the maximum number of spots.

        Returns
        -------
        MaximumNumberOfSpots
            A MaximumNumberOfSpots pydantic model
        """
        if len(self.x_nonzero) == 0:
            logger.info("No crystals found!")
            return None

        y_coord, x_coord = np.unravel_index(
            np.argmax(self.filtered_array, axis=None), self.filtered_array.shape
        )

        maximum_number_of_spots = MaximumNumberOfSpots(
            pixel_position=(x_coord, y_coord)
        )

        if self.grid_scan_motor_coordinates is not None:
            if not self.grid_scan_motor_coordinates.use_centring_table:
                maximum_number_of_spots.motor_positions = MotorCoordinates(
                    alignment_y=self.alignment_y_coords[
                        y_coord,
                        x_coord,
                    ],
                    alignment_z=self.alignment_z_coords[
                        y_coord,
                        x_coord,
                    ],
                    sample_x=self.grid_scan_motor_coordinates.initial_pos_sample_x,
                    sample_y=self.grid_scan_motor_coordinates.initial_pos_sample_y,
                    alignment_x=self.grid_scan_motor_coordinates.alignment_x_pos,
                    omega=self.grid_scan_motor_coordinates.omega,
                    plate_translation=self.grid_scan_motor_coordinates.plate_translation,
                )

        return maximum_number_of_spots

    def plot_crystal_finder_results(
        self,
        save: bool = False,
        interpolation: str = None,
        plot_centers_of_mass: bool = True,
        filename: str = "crystal_finder_results",
    ) -> tuple[list[CrystalPositions], list[dict[str, int]], MaximumNumberOfSpots]:
        """
        Calculates the center of mass of individual crystals in a loop,
        the location and size of all crystals, and estimates
        the distance between overlapping crystals. Finally these results
        are plotted

        Parameters
        ----------
        save : bool, optional
            If true, we save the image
        interpolation : str, optional
            Interpolation used by plt.imshow(). Could be any of the interpolations
            described in the plt.imshow documentation, by default None
        plot_center_of_mass : bool, optional
            If true, we plot the centers of mass
        filename : str
            Name of the image. The filename is used only if save=True,
            by default crystal_finder_results

        Returns
        -------
        tuple[list[CrystalPositions], list[dict[str, int]]]
            A list containing the centers of mass of all crystals in the loop,
            a list of dictionaries containing information about the locations and sizes
            of all crystals, and a list of dictionaries describing the distance between
            all overlapping crystals in a loop
        """

        (
            list_of_crystal_locations,
            distance_list,
            maximum_number_of_spots_location,
        ) = self.find_crystals_and_overlapping_crystal_distances()

        if list_of_crystal_locations is None or distance_list is None:
            return None, None, None

        logger.info(f"List of crystal locations: {list_of_crystal_locations}")

        marker_list = [
            ".",
            "+",
            "v",
            "p",
            ">",
            "s",
            "P",
            "D",
            "X",
            "1",
            "2",
            "<",
            "3",
            "4",
            "^",
            "o",
        ]
        golden_ratio = 1.618
        plt.figure(figsize=[7 * golden_ratio, 7])
        c = plt.imshow(self.filtered_array, interpolation=interpolation)
        plt.scatter(
            maximum_number_of_spots_location.pixel_position[0],
            maximum_number_of_spots_location.pixel_position[1],
            marker="s",
            s=200,
            label="Maximum number of spots",
        )
        if plot_centers_of_mass:
            for i, crystal_location in enumerate(list_of_crystal_locations):
                try:
                    plt.scatter(
                        crystal_location.center_of_mass_pixels[0],
                        crystal_location.center_of_mass_pixels[1],
                        label=f"Center of mass: Crystal #{i}",
                        marker=marker_list[i],
                        s=200,
                        color="red",
                    )
                except IndexError:  # we ran out of markers :/
                    plt.scatter(
                        crystal_location.center_of_mass_pixels[0],
                        crystal_location.center_of_mass_pixels[1],
                        label=f"Center of mass: Crystal #{i}",
                        s=200,
                        color="red",
                    )
            plt.legend(labelspacing=1.5)

        for crystal_locations in list_of_crystal_locations:
            self._plot_rectangle_surrounding_crystal(crystal_locations)

        plt.colorbar(c, label="Number of spots")
        if save:
            plt.savefig(filename)
        # plt.close()
        return (
            list_of_crystal_locations,
            distance_list,
            maximum_number_of_spots_location,
        )

    def _plot_rectangle_surrounding_crystal(
        self,
        rectangle_coordinates: CrystalPositions,
    ) -> None:
        """
        Plots a rectangle surrounding a crystal

        Parameters
        ----------
        rectangle_coordinates : CrystalPositions
            A CrystalPositions pydantic model obtained from the self._rectangle_coords method

        Returns
        -------
        None
        """
        # top
        x = np.linspace(
            rectangle_coordinates.bottom_left_pixel_coords[0] - 0.5,
            rectangle_coordinates.top_right_pixel_coords[0] + 0.5,
            100,
        )
        z = (rectangle_coordinates.top_right_pixel_coords[1] - 0.5) * np.ones(len(x))
        plt.plot(x, z, color="red", linestyle="--")

        # Bottom
        x = np.linspace(
            rectangle_coordinates.bottom_left_pixel_coords[0] - 0.5,
            rectangle_coordinates.top_right_pixel_coords[0] + 0.5,
            100,
        )
        z = (rectangle_coordinates.bottom_left_pixel_coords[1] + 0.5) * np.ones(len(x))
        plt.plot(x, z, color="red", linestyle="--")

        # Right side
        z = np.linspace(
            rectangle_coordinates.top_right_pixel_coords[1] - 0.5,
            rectangle_coordinates.bottom_left_pixel_coords[1] + 0.5,
            100,
        )
        x = (rectangle_coordinates.top_right_pixel_coords[0] + 0.5) * np.ones(len(x))
        plt.plot(x, z, color="red", linestyle="--")

        # Left side
        z = np.linspace(
            rectangle_coordinates.top_right_pixel_coords[1] - 0.5,
            rectangle_coordinates.bottom_left_pixel_coords[1] + 0.5,
            100,
        )
        x = (rectangle_coordinates.bottom_left_pixel_coords[0] - 0.5) * np.ones(len(x))
        plt.plot(x, z, color="red", linestyle="--")


class CrystalFinder3D:
    """
    Finds the 3D coordinates of multiple crystals in a loop, as well their 3D centers of mass
    based on the edge and flat coordinates of a crystal, which can be obtained
    using the CrystalFinder class.
    """

    def __init__(
        self,
        crystal_coordinates_flat: list[CrystalPositions],
        crystal_coordinates_edge: list[CrystalPositions],
        dist_flat: list[dict],
        dist_edge: list[dict],
        raster_grid_coordinates_flat: Optional[RasterGridCoordinates] = None,
        raster_grid_coordinates_edge: Optional[RasterGridCoordinates] = None,
        beam_position: Optional[tuple[int, int]] = None,
        pixels_per_mm: Optional[float] = None,
        aligned_loop_position: Optional[MotorCoordinates] = None,
    ) -> None:
        """_summary_

        Parameters
        ----------
        crystal_coordinates_flat : list[CrystalPositions]
            The flat coordinates of the crystal obtained from the CrystalFinder class
        crystal_coordinates_edge : list[CrystalPositions]
            The edge coordinates of the crystal obtained from the CrystalFinder class
        dist_flat : list[dict]
            The distance between crystals (flat)
        dist_edge : list[dict]
            The distance between crystals (edge)
        raster_grid_coordinates_flat : Optional[RasterGridCoordinates], optional
            The flat raster grid coordinates, by default None
        raster_grid_coordinates_edge : Optional[RasterGridCoordinates], optional
            The edge raster grid coordinates, by default None
        beam_position : Optional[tuple[int, int]], optional
            The beam position, by default None
        pixels_per_mm : Optional[float], optional
            The md3 camera pixels per mm , by default None
        aligned_loop_position : Optional[MotorCoordinates], optional
            The centered position of the loop. This value is obtained usually
            from the optical centering bluesky plan, by default None

        Returns
        -------
        None
        """
        self.crystal_coordinates_flat = crystal_coordinates_flat
        self.crystal_coordinates_edge = crystal_coordinates_edge
        self.raster_grid_coordinates_flat = raster_grid_coordinates_flat
        self.raster_grid_coordinates_edge = raster_grid_coordinates_edge
        self.beam_position = beam_position
        self.pixels_per_mm = pixels_per_mm
        self.aligned_loop_position = aligned_loop_position

        self.dist_flat = dist_flat
        self.dist_edge = dist_edge

    def _map_grid_to_camera_pixel_coordinates(self) -> tuple[list[list], list[list]]:
        """
        Maps the grid pixel coordinates to the pixel coordinates of the md3 camera.
        Once the md3 camera pixel coordinates have been found, we convert
        the pixel positions to mm.

        Returns
        -------
        tuple[list[list], list[list]]

        """

        x_pixels_flat = np.linspace(
            self.raster_grid_coordinates_flat.top_left_pixel_coordinates[0],
            self.raster_grid_coordinates_flat.bottom_right_pixel_coordinates[0],
            self.raster_grid_coordinates_flat.number_of_columns,
            dtype=int,
        )
        y_pixels_flat = np.linspace(
            self.raster_grid_coordinates_flat.top_left_pixel_coordinates[1],
            self.raster_grid_coordinates_flat.bottom_right_pixel_coordinates[1],
            self.raster_grid_coordinates_flat.number_of_rows,
            dtype=int,
        )

        x_pixels_edge = np.linspace(
            self.raster_grid_coordinates_edge.top_left_pixel_coordinates[0],
            self.raster_grid_coordinates_edge.bottom_right_pixel_coordinates[0],
            self.raster_grid_coordinates_edge.number_of_columns,
            dtype=int,
        )
        y_pixels_edge = np.linspace(
            self.raster_grid_coordinates_edge.top_left_pixel_coordinates[1],
            self.raster_grid_coordinates_edge.bottom_right_pixel_coordinates[1],
            self.raster_grid_coordinates_edge.number_of_rows,
            dtype=int,
        )

        x_center_of_mass_coordinates = []
        y_center_of_mass_coordinates = []

        for (crystal_edge, crystal_flat) in zip(
            self.crystal_coordinates_edge, self.crystal_coordinates_flat
        ):
            x_coords = [
                x_pixels_flat[crystal_flat.center_of_mass_pixels[0]]
                / self.pixels_per_mm,
                x_pixels_edge[crystal_edge.center_of_mass_pixels[0]]
                / self.pixels_per_mm,
            ]
            y_coords = [
                y_pixels_flat[crystal_flat.center_of_mass_pixels[1]]
                / self.pixels_per_mm,
                y_pixels_edge[crystal_edge.center_of_mass_pixels[1]]
                / self.pixels_per_mm,
            ]

            x_center_of_mass_coordinates.append(x_coords)
            y_center_of_mass_coordinates.append(y_coords)

        return x_center_of_mass_coordinates, y_center_of_mass_coordinates

    def two_point_centre(self, x_coords: list, omega_list: list) -> npt.NDArray:
        """
        Two point centre function

        Parameters
        ----------
        x_coords : list
            A list of x-coordinates values obtained during
            three-click centering in mm
        omega_list : list
            A list containing a list of omega values in radians

        Returns
        -------
        npt.NDArray
            The optimised parameters: (amplitude, phase)
        """

        optimised_params, _ = optimize.curve_fit(
            self._centering_function, omega_list, x_coords, p0=[1.0, 0.0]
        )

        return optimised_params

    def _centering_function(
        self, theta: float, amplitude: float, phase: float
    ) -> float:
        """
        Sine function used to determine the motor positions at which a sample
        is aligned with the center of the beam.

        Note that the period of the sine function in this case is T=2*pi, therefore
        omega = 2 * pi / T = 1. Additionally the offset is a constant calculated
        experimentally, so effectively we fit a function with two unknowns:
        phase and theta:

        result = amplitude*np.sin(omega*theta + phase) + offset
               = amplitude*np.sin(theta + phase) + offset

        Parameters
        ----------
        theta : float
            Angle in radians
        amplitude : float
            Amplitude of the sine function in mm
        phase : float
            Phase in radians

        Returns
        -------
        float
            The value of the sine function at a given angle, amplitude and phase
        """
        offset = self.beam_position[0] / self.pixels_per_mm
        return amplitude * np.sin(theta + phase) + offset

    def center_of_mass_motor_positions(self) -> list[MotorCoordinates]:
        """
        Calculates the center of mass of al crystals. The calculated centers of mass are
        aligned with the center of the beam.

        Returns
        -------
        list[MotorCoordinates]
            A list of center of mass motor coordinates
        """
        x_coordinates, y_coordinates = self._map_grid_to_camera_pixel_coordinates()
        omega_positions = np.radians(
            [
                self.raster_grid_coordinates_flat.omega,
                self.raster_grid_coordinates_edge.omega,
            ]
        )

        center_of_mass_list = []
        for (x_coords, y_coords) in zip(x_coordinates, y_coordinates):
            average_y_position = np.mean(y_coords)

            amplitude, phase = self.two_point_centre(x_coords, omega_positions)
            delta_sample_y = amplitude * np.sin(phase)
            delta_sample_x = amplitude * np.cos(phase)

            delta_alignment_y = average_y_position - (
                self.beam_position[1] / self.pixels_per_mm
            )
            center_of_mass = MotorCoordinates(
                sample_x=self.aligned_loop_position.sample_x + delta_sample_x,
                sample_y=self.aligned_loop_position.sample_y + delta_sample_y,
                alignment_x=self.aligned_loop_position.alignment_x,
                alignment_y=self.aligned_loop_position.alignment_y + delta_alignment_y,
                alignment_z=self.aligned_loop_position.alignment_z,
            )
            center_of_mass_list.append(center_of_mass)
        return center_of_mass_list

    def cube_vertices(self) -> list[tuple[int, int, int]]:
        """
        Calculates the vertices of an array from the flat and edge coordinates.
        These coordinates should be obtained from the CrystalFinder.
        If an index error occurs, it means that are overlapping crystals, in which case
        we use the coordinates of the j-th crystal in replacement of its
        corresponding i-th overlapping crystal to infer the volume.
        However, this won't result in accurate results. TODO: This can be improved!

        Returns
        -------
        list[tuple[int, int, int]]
            A list containing the vertices describing the cube surrounding a crystal
        """
        vertices = []
        for i in range(len(self.crystal_coordinates_flat)):
            try:
                vertices.append(
                    self.vertices_list(
                        self.crystal_coordinates_flat,
                        self.crystal_coordinates_edge,
                        i,
                        i,
                    )
                )
            except IndexError:
                for j, dist in enumerate(self.dist_flat):
                    overlapping_index = dist[str(j)]
                    if overlapping_index == i:
                        vertices.append(
                            self.vertices_list(
                                self.crystal_coordinates_flat,
                                self.crystal_coordinates_edge,
                                i,
                                j,
                            )
                        )
                        logger.info(f"Crystal {i} is overlapping with crystal {j}")
                        break
        return vertices

    def vertices_list(
        self,
        coords_flat: list[CrystalPositions],
        coords_edge: list[CrystalPositions],
        coords_flat_index: int,
        coords_edge_index: int,
    ):
        vertices_list = [
            (
                coords_flat[coords_flat_index].min_x,
                coords_flat[coords_flat_index].min_y,
                coords_edge[coords_edge_index].min_y,
            ),
            (
                coords_flat[coords_flat_index].min_x,
                coords_flat[coords_flat_index].min_y,
                coords_edge[coords_edge_index].max_y,
            ),
            (
                coords_flat[coords_flat_index].min_x,
                coords_flat[coords_flat_index].max_y,
                coords_edge[coords_edge_index].min_y,
            ),
            (
                coords_flat[coords_flat_index].min_x,
                coords_flat[coords_flat_index].max_y,
                coords_edge[coords_edge_index].max_y,
            ),
            (
                coords_flat[coords_flat_index].max_x,
                coords_flat[coords_flat_index].min_y,
                coords_edge[coords_edge_index].min_y,
            ),
            (
                coords_flat[coords_flat_index].max_x,
                coords_flat[coords_flat_index].min_y,
                coords_edge[coords_edge_index].max_y,
            ),
            (
                coords_flat[coords_flat_index].max_x,
                coords_flat[coords_flat_index].max_y,
                coords_edge[coords_edge_index].min_y,
            ),
            (
                coords_flat[coords_flat_index].max_x,
                coords_flat[coords_flat_index].max_y,
                coords_edge[coords_edge_index].max_y,
            ),
        ]

        return vertices_list

    def crystal_volumes(self) -> list[CrystalVolume]:
        """
        Calculates the crystal volumes in a loop

        Returns
        -------
        list[CrystalVolume]
            A list of CrystalVolume pydantic models
        """
        volume_list = []
        for (flat, edge) in zip(
            self.crystal_coordinates_flat, self.crystal_coordinates_edge
        ):
            width = flat.width_micrometers
            height = flat.height_micrometers
            depth = edge.width_micrometers
            if int(flat.height_micrometers) != int(edge.height_micrometers):
                warnings.warn(
                    "The height inferred from the flat and edge scans are "
                    "not equal, something has gone wrong!"
                )
            volume_list.append(
                CrystalVolume(
                    width=width,
                    height=height,
                    depth=depth,
                    volume=width * height * depth,
                )
            )
        return volume_list

    def plot_crystals(
        self,
        plot_centers_of_mass: bool = True,
        save: bool = False,
        filename: str = "crystal_finder_3d_results",
    ) -> list[CrystalVolume]:
        """
        Plots the cubes surrounding crystals based on the edge and flat coordinates found by
        the CrystalFinder.
        FIXME: get the centers of mass for overlapping crystals. At the moment if two
        crystals overlap, we cannot accurately find the centers of mass in 3D (2D works fine),
        and we get an error


        Parameters
        ----------
        plot_centers_of_mass : bool, optional
            If true, plot the centers of mass of each crystal, by default True
        save : bool, optional
            If true, we save the CrystalFinder3D plot, be default False
        filename : str, optional
            Name of the file if save=True, by default crystal_finder_3d_results

        Returns
        -------
        list[CrystalVolume]
            A list of crystal volumes
        """
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")

        vertices = self.cube_vertices()

        for i, z in enumerate(vertices):
            # set vertices connectors
            verts = [
                [z[0], z[1], z[5], z[4]],
                [z[4], z[6], z[7], z[5]],
                [z[7], z[6], z[2], z[3]],
                [z[2], z[0], z[1], z[3]],
                [z[5], z[7], z[3], z[1]],
                [z[0], z[2], z[6], z[4]],
            ]
            # plot sides
            ax.add_collection3d(
                Poly3DCollection(
                    verts,
                    facecolors="blue",
                    linewidths=1,
                    edgecolors="black",
                    alpha=0.1,
                )
            )
            # FIXME: get the centers of mass for overlapping crystals
            if plot_centers_of_mass:
                ax.scatter3D(
                    self.crystal_coordinates_flat[i].center_of_mass_pixels[0],
                    self.crystal_coordinates_flat[i].center_of_mass_pixels[1],
                    self.crystal_coordinates_edge[i].center_of_mass_pixels[1],
                    label=f"CM Crystal {i}",
                    color="r",
                )

        min_lim = min(min(min(vertices)))
        max_lim = max(max(max(vertices)))
        ax.set_xlim3d(min_lim, max_lim)
        ax.set_ylim3d(min_lim, max_lim)
        ax.set_zlim3d(min_lim, max_lim)
        ax.set_xlabel("x")
        ax.set_ylabel("y")
        ax.set_zlabel("z")
        plt.legend()

        if save:
            plt.savefig(filename)

        return self.crystal_volumes()


if __name__ == "__main__":

    path = "/mnt/shares/smd_share/4Mrasterdata/SCOMPMX-273/spotfinder_results"

    # Test crystal finder with random raster grid motor coordinates
    raster_grid_coords = RasterGridCoordinates(
        use_centring_table=False,
        initial_pos_alignment_z=1,
        final_pos_alignment_z=1.2,
        initial_pos_sample_x=-0.02,
        final_pos_sample_x=-0.1,
        initial_pos_sample_y=0.6,
        final_pos_sample_y=0.7,
        initial_pos_alignment_y=0.01,
        final_pos_alignment_y=0.4,
        center_pos_sample_x=-0.06,
        center_pos_sample_y=0.7,
        width_mm=0.18,
        height_mm=0.42,
        number_of_columns=1,
        number_of_rows=2,
        omega=90,
        alignment_x_pos=0,
        plate_translation=12,
    )
    # Edge
    flat = np.load(f"{path}/flat.npy")
    # flat = np.rot90(np.append(flat, flat, axis=0), k=1)
    # flat = np.append(flat, flat, axis=0)
    raster_grid_coords.number_of_columns = flat.shape[1]
    raster_grid_coords.number_of_rows = flat.shape[0]

    t = time.perf_counter()
    crystal_finder = CrystalFinder(
        flat, threshold=5, grid_scan_motor_coordinates=raster_grid_coords
    )

    (
        coords_flat,
        distance_flat,
        maximum_number_of_spots_location,
    ) = crystal_finder.plot_crystal_finder_results(save=True, filename="flat")
    print("\nCrystal locations and sizes:\n", coords_flat)
    print("\nDistance between overlapping crystals:\n", distance_flat)
    plt.title("Flat")

    # Flat
    edge = np.load(f"{path}/edge.npy")
    # edge = np.append(edge, edge, axis=1)
    raster_grid_coords.number_of_columns = edge.shape[1]
    raster_grid_coords.number_of_rows = edge.shape[0]
    t = time.perf_counter()
    crystal_finder = CrystalFinder(
        edge, threshold=5, grid_scan_motor_coordinates=raster_grid_coords
    )

    (
        coords_edge,
        distance_edge,
        maximum_number_of_spots_location,
    ) = crystal_finder.plot_crystal_finder_results(save=True, filename="edge")

    print("\nCrystal locations and sizes:\n", coords_edge)
    print("\nDistance between overlapping crystals:\n", distance_edge)
    print("Calculation time (s):", time.perf_counter() - t)
    plt.title("Edge")

    crystal_finder_3d = CrystalFinder3D(
        coords_flat, coords_edge, distance_flat, distance_edge
    )
    crystal_volumes = crystal_finder_3d.plot_crystals(
        plot_centers_of_mass=True, save=True
    )
    print("Crystal volumes:", crystal_volumes)
