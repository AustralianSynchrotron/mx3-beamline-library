import asyncio
import logging
import pickle
import time
from copy import deepcopy
from typing import Union

import matplotlib.pyplot as plt
import numpy as np
import numpy.typing as npt
import redis
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from scipy.ndimage import center_of_mass

from mx3_beamline_library.plans.basic_scans import (
    _calculate_alignment_y_motor_coords,
    _calculate_alignment_z_motor_coords,
    _calculate_sample_x_coords,
    _calculate_sample_y_coords,
)
from mx3_beamline_library.schemas.crystal_finder import (
    CrystalPositions,
    CrystalVolume,
    MaximumNumberOfSpots,
    MotorCoordinates,
)
from mx3_beamline_library.schemas.xray_centering import (
    RasterGridCoordinates,
    SpotfinderResults,
)

logger = logging.getLogger(__name__)
_stream_handler = logging.StreamHandler()
logging.getLogger(__name__).addHandler(_stream_handler)
logging.getLogger(__name__).setLevel(logging.INFO)


class CrystalFinder:
    """
    Calculates the center of mass of individual crystals in a loop, finds the
    size of each crystal, and determines the vertical distance
    between overlapping crystals.

    Attributes
    ----------
    y_nonzero : npt.NDArray
        Nonzero y coordinates of self.filtered_array
    x_nonzero : npt.NDArray
        Nonzero x coordinates of self.filtered_array
    list_of_island_indices : list[set[tuple[int, int]]]
        A list of a set of indices describing individual islands
    list_of_island_arrays : list[npt.NDArray]
        A list of numpy arrays describing individual islands
    _nonzero_coords : npt.NDArray
        Nonzero coordinate array. This array is for internal use only.
        Values of this array will be deleted during runtime for performance purposes
    """

    def __init__(
        self,
        number_of_spots: npt.NDArray,
        threshold: float,
        grid_scan_motor_coordinates: RasterGridCoordinates = None,
    ) -> None:
        """
        Parameters
        ----------
        number_of_spots : npt.NDArray
            An array containing the number of spots obtained from spotfinding.
            The array's shape should be (n_rows, n_cols)
        threshold : float
            We replace all numbers below this threshold with zeros. The resulting
            arrays is saved as self.filtered_array
        grid_scan_motor_coordinates : RasterGridCoordinates
            A RasterGridCoordinates pydantic model generated by the
            optical_and_ray_centering_plan which contains information about the flat
            and edge raster grids. This is used to map pixel coordinates to motor coordinates,
            by default None. If this parameter is not given, only pixel coordinates are
             calculated

        Returns
        -------
        None
        """
        self.number_of_spots = number_of_spots
        self.filtered_array = np.where(
            self.number_of_spots < threshold, 0, number_of_spots
        )

        self.y_nonzero, self.x_nonzero = np.nonzero(self.filtered_array)

        self.list_of_island_indices: list[set[tuple[int, int]]] = None
        self.list_of_islands: list[npt.NDArray] = None

        self._nonzero_coords = np.array([self.x_nonzero, self.y_nonzero]).transpose()
        logger.info(f"Number of non-zero pixels: {len(self.y_nonzero)}")

        self.grid_scan_motor_coordinates = grid_scan_motor_coordinates
        self.sample_x_coords = None
        self.sample_y_coords = None
        self.alignment_y_coords = None

    def _find_adjacent_pixels(self, pixel: tuple[int, int]) -> set[tuple[int, int]]:
        """
        Finds all adjacent pixels of a single pixel containing values different from zero.
        Once we have calculated all adjacent pixels, we remove them from self._nonzero_coords
        to avoid counting them again.

        Parameters
        ----------
        pixel : tuple[int, int]
            A pixel coordinate

        Returns
        -------
        set[tuple[int, int]]
            A set containing adjacent pixels of a single pixel
        """
        if not len(self._nonzero_coords):
            # We have taken into account all pixels, do nothing
            return set()

        # Distance between pixels
        diff = np.array(pixel) - self._nonzero_coords
        distance_between_pixels = np.sqrt(diff[:, 0] ** 2 + diff[:, 1] ** 2)
        adjacent_args = np.argwhere(distance_between_pixels <= np.sqrt(2)).flatten()

        adjacent_pixels = set()
        for arg in adjacent_args:
            adjacent_pixels.update({tuple(self._nonzero_coords[arg])})

        # Remove pixels we have already considered
        self._nonzero_coords = np.delete(self._nonzero_coords, adjacent_args, axis=0)

        return adjacent_pixels

    def _find_individual_islands(
        self, start_coord: tuple[int, int], number_of_spots: npt.NDArray
    ) -> tuple[npt.NDArray, set[tuple[int, int]]]:
        """
        Finds individual islands

        Parameters
        ----------
        start_coord : tuple[int, int]
            We find an island starting from start_coord
        number_of_spots : npt.NDArray
            An array containing the number of spots

        Returns
        -------
        tuple[npt.NDArray, set[tuple[int, int]]]
            The individual island array, and it's corresponding indices
        """
        adjacent_pixels = self._find_adjacent_pixels(start_coord)
        length = [0, len(adjacent_pixels)]
        adjacent_pixels_list = [set(), deepcopy(adjacent_pixels)]

        while length[-1] - length[-2]:
            non_repeated_pixels = adjacent_pixels_list[-1] - adjacent_pixels_list[-2]
            for coord in non_repeated_pixels:
                adjacent_pixels.update(self._find_adjacent_pixels(coord))
            length.append(len(adjacent_pixels))
            adjacent_pixels_list.append(deepcopy(adjacent_pixels))

        island = np.zeros(number_of_spots.shape)
        for index in adjacent_pixels:
            island[index[1]][index[0]] = number_of_spots[index[1]][index[0]]

        return island, adjacent_pixels

    def _find_all_islands(self) -> None:
        """
        Finds all islands in self.filtered_array. The values of self.list_of_island_indices and
        self.list_of_islands are updated here.

        Returns
        -------
        None
        """
        logger.info("Finding islands...")
        t = time.perf_counter()
        self.list_of_island_indices = []

        island, island_indices = self._find_individual_islands(
            (self.x_nonzero[0], self.y_nonzero[0]), self.filtered_array
        )
        self.list_of_island_indices.append(island_indices.copy())

        self.list_of_islands = [island]
        for coord in self._nonzero_coords:
            if tuple(coord) not in island_indices:
                island_tmp, island_indices_tmp = self._find_individual_islands(
                    coord, self.filtered_array
                )
                self.list_of_island_indices.append(island_indices_tmp.copy())
                island_indices.update(island_indices_tmp)

                self.list_of_islands.append(island_tmp)
        logger.info(
            f"It took {time.perf_counter() - t} [s] to find all "
            f"{len(self.list_of_islands)} islands in the loop"
        )

    def _find_centers_of_mass(self) -> list[tuple[int, int]]:
        """
        Calculates the center of mass of all islands found in self.filtered_array

        Returns
        -------
        list[tuple[int, int]]
            A list containing the center of mass of individual islands
        """
        if self.list_of_islands is None or self.list_of_island_indices is None:
            self._find_all_islands()

        center_of_mass_list = []
        for island in self.list_of_islands:
            y_cm, x_cm = center_of_mass(island)
            center_of_mass_list.append((round(x_cm), round(y_cm)))

        return center_of_mass_list

    def find_crystals(self) -> list[CrystalPositions]:
        """
        Calculates the crystal locations, sizes, and centers of mass in a loop in
        units of pixels. To calculate the height and width of the crystal, we assume
        that the crystal is well approximated by a rectangle.
        If self.grid_scan_motor_coordinates is not None, we additionally calculate
        the motor positions corresponding to the locations of the crystals,
        and their centers of mass.

        Returns
        -------
        list[CrystalPositions]
            A list of CrystalPositions Pydantic models containing information about the
            locations of all crystals as well as their sizes.
        """
        if len(self.x_nonzero) == 0:
            logger.info("No crystals found!")
            return None

        if self.list_of_islands is None or self.list_of_island_indices is None:
            self._find_all_islands()

        list_of_crystal_locations_and_sizes: list[CrystalPositions] = []
        for index in self.list_of_island_indices:
            list_of_crystal_locations_and_sizes.append(self._rectangle_coords(index))

        centers_of_mass = self._find_centers_of_mass()

        for (i, crystal_location) in enumerate(list_of_crystal_locations_and_sizes):
            crystal_location.center_of_mass_pixels = centers_of_mass[i]

        # Convert pixel coordinates to motor coordinates
        if self.grid_scan_motor_coordinates is not None:
            for crystal_location in list_of_crystal_locations_and_sizes:
                if self.grid_scan_motor_coordinates.use_centring_table:
                    crystal_location.center_of_mass_motor_coordinates = (
                        MotorCoordinates(
                            sample_x=self.sample_x_coords[
                                crystal_location.center_of_mass_pixels[1],
                                crystal_location.center_of_mass_pixels[0],
                            ],
                            sample_y=self.sample_y_coords[
                                crystal_location.center_of_mass_pixels[1],
                                crystal_location.center_of_mass_pixels[0],
                            ],
                            alignment_y=self.alignment_y_coords[
                                crystal_location.center_of_mass_pixels[1],
                                crystal_location.center_of_mass_pixels[0],
                            ],
                        )
                    )
                else:
                    crystal_location.center_of_mass_motor_coordinates = (
                        MotorCoordinates(
                            alignment_y=self.alignment_y_coords[
                                crystal_location.center_of_mass_pixels[1],
                                crystal_location.center_of_mass_pixels[0],
                            ],
                            alignment_z=self.alignment_z_coords[
                                crystal_location.center_of_mass_pixels[1],
                                crystal_location.center_of_mass_pixels[0],
                            ],
                        )
                    )

                (
                    width_micrometers,
                    heigh_micrometers,
                ) = self._crystal_width_and_height_in_micrometers(crystal_location)
                crystal_location.width_micrometers = width_micrometers
                crystal_location.height_micrometers = heigh_micrometers

        return list_of_crystal_locations_and_sizes

    def _crystal_width_and_height_in_micrometers(
        self,
        crystal_positions: CrystalPositions,
    ) -> tuple[float, float]:
        """
        Calculates the width and height of the crystal in micrometers

        Parameters
        ----------
        crystal_positions : CrystalPositions
            A CrystalPositions pydantic model

        Returns
        -------
        tuple[float, float]
            The width and height in micrometers
        """
        pixels_per_mm_x = (
            self.grid_scan_motor_coordinates.number_of_columns
            / self.grid_scan_motor_coordinates.width_mm
        )
        pixels_per_mm_y = (
            self.grid_scan_motor_coordinates.number_of_rows
            / self.grid_scan_motor_coordinates.height_mm
        )

        width_micrometers = crystal_positions.width / pixels_per_mm_x * 1000
        height_micrometers = crystal_positions.height / pixels_per_mm_y * 1000
        return width_micrometers, height_micrometers

    def find_crystals_and_overlapping_crystal_distances(
        self,
    ) -> tuple[list[CrystalPositions], list[dict[str, int]], MaximumNumberOfSpots]:
        """
        Calculates the distance between all overlapping crystals in a loop in units of
        pixels, the crystal locations, and their corresponding sizes (in pixels). The distance
        between the i-th and j-th overlapping crystal is saved in a key following the format:
        f"distance_{i}_{j}"

        Returns
        -------
        list[dict], list[dict[str, int]]
            A list of dictionaries containing information about the locations of all
            crystals as well as their sizes, and a list of dictionaries describing
            the distance between all overlapping crystals in a loop
        """
        list_of_crystal_locations_and_sizes = self.find_crystals()

        if list_of_crystal_locations_and_sizes is None:
            return None, None

        distance_list = []
        for i in range(len(self.list_of_island_indices)):
            for j in range(len(self.list_of_island_indices)):
                if j > i:
                    coords_1 = list_of_crystal_locations_and_sizes[i]
                    coords_2 = list_of_crystal_locations_and_sizes[j]
                    if (coords_2.min_x <= coords_1.min_x <= coords_2.max_x) or (
                        coords_2.min_x <= coords_1.max_x <= coords_2.max_x
                    ):
                        # Note that the -1 is added because we're subtracting indices
                        distance = (
                            min(
                                [
                                    abs(coords_1.max_y - coords_2.min_y),
                                    abs(coords_2.max_y - coords_1.min_y),
                                ]
                            )
                            - 1
                        )
                        distance_list.append({f"distance_{i}_{j}": distance, str(i): j})

        maximum_number_of_spots_position = self.maximum_number_of_spots_location()

        return (
            list_of_crystal_locations_and_sizes,
            distance_list,
            maximum_number_of_spots_position,
        )

    def _rectangle_coords(
        self, island_indices: set[tuple[int, int]]
    ) -> CrystalPositions:
        """
        Fits a crystal with a rectangle given the indices of an island. Based on that
        assumption we calculate the bottom_left and bottom right coordinates of the
        rectangle, its width, height, and minimum and maximum x and y values

        Parameters
        ----------
        island_indices : set[tuple[int, int]]
            Indices of an island

        Returns
        -------
        dict
            A dictionary containing information about the coordinated of the crystal
            as well as its width and height
        """

        x_vals = []
        y_vals = []
        for coord in island_indices.copy():
            x_vals.append(coord[0])
            y_vals.append(coord[1])

        min_x = min(x_vals)
        max_x = max(x_vals)
        min_y = min(y_vals)
        max_y = max(y_vals)

        bottom_left = (min_x, max_y)
        top_right = (max_x, min_y)
        width = max_x - min_x
        height = max_y - min_y
        crystal_positions = CrystalPositions(
            bottom_left_pixel_coords=bottom_left,
            top_right_pixel_coords=top_right,
            width=width,
            height=height,
            min_x=min_x,
            max_x=max_x,
            min_y=min_y,
            max_y=max_y,
        )

        if self.grid_scan_motor_coordinates is not None:
            if not self.grid_scan_motor_coordinates.use_centring_table:
                self.alignment_z_coords = np.fliplr(
                    _calculate_alignment_z_motor_coords(
                        self.grid_scan_motor_coordinates
                    )
                )
                _alignment_y_coords = np.fliplr(
                    _calculate_alignment_y_motor_coords(
                        self.grid_scan_motor_coordinates
                    )
                )
                self.alignment_y_coords = np.zeros(_alignment_y_coords.shape)
                for i in range(_alignment_y_coords.shape[1]):
                    if i % 2:
                        self.alignment_y_coords[:, i] = np.flipud(
                            _alignment_y_coords[:, i]
                        )
                    else:
                        self.alignment_y_coords[:, i] = _alignment_y_coords[:, i]

                crystal_positions.bottom_left_motor_coordinates = MotorCoordinates(
                    alignment_y=self.alignment_y_coords[
                        crystal_positions.bottom_left_pixel_coords[1],
                        crystal_positions.bottom_left_pixel_coords[0],
                    ],
                    alignment_z=self.alignment_z_coords[
                        crystal_positions.bottom_left_pixel_coords[1],
                        crystal_positions.bottom_left_pixel_coords[0],
                    ],
                )

                crystal_positions.top_right_motor_coordinates = MotorCoordinates(
                    alignment_y=self.alignment_y_coords[
                        crystal_positions.top_right_pixel_coords[1],
                        crystal_positions.top_right_pixel_coords[0],
                    ],
                    alignment_z=self.alignment_z_coords[
                        crystal_positions.top_right_pixel_coords[1],
                        crystal_positions.top_right_pixel_coords[0],
                    ],
                )
            else:
                self.sample_x_coords = _calculate_sample_x_coords(
                    self.grid_scan_motor_coordinates
                )
                self.sample_y_coords = _calculate_sample_y_coords(
                    self.grid_scan_motor_coordinates
                )
                self.alignment_y_coords = _calculate_alignment_y_motor_coords(
                    self.grid_scan_motor_coordinates
                )

                # TODO: validate this coordinates
                crystal_positions.bottom_left_motor_coordinates = MotorCoordinates(
                    sample_x=self.sample_x_coords[
                        crystal_positions.bottom_left_pixel_coords[1],
                        crystal_positions.bottom_left_pixel_coords[0],
                    ],
                    sample_y=self.sample_y_coords[
                        crystal_positions.bottom_left_pixel_coords[1],
                        crystal_positions.bottom_left_pixel_coords[0],
                    ],
                    alignment_y=self.alignment_y_coords[
                        crystal_positions.bottom_left_pixel_coords[1],
                        crystal_positions.bottom_left_pixel_coords[0],
                    ],
                )

                crystal_positions.top_right_motor_coordinates = MotorCoordinates(
                    sample_x=self.sample_x_coords[
                        crystal_positions.top_right_pixel_coords[1],
                        crystal_positions.top_right_pixel_coords[0],
                    ],
                    sample_y=self.sample_y_coords[
                        crystal_positions.top_right_pixel_coords[1],
                        crystal_positions.top_right_pixel_coords[0],
                    ],
                    alignment_y=self.alignment_y_coords[
                        crystal_positions.top_right_pixel_coords[1],
                        crystal_positions.top_right_pixel_coords[0],
                    ],
                )
        return crystal_positions

    def maximum_number_of_spots_location(self) -> MaximumNumberOfSpots:
        """
        Finds the maximum number of spots positions (x, y) in the array.
        If self.grid_scan_motor_coordinates  is not None, we additionally
        calculate the motor positions associated the with the maximum number of spots.

        """
        y_coord, x_coord = np.unravel_index(
            np.argmax(self.filtered_array, axis=None), self.filtered_array.shape
        )

        maximum_number_of_spots = MaximumNumberOfSpots(
            pixel_position=(x_coord, y_coord)
        )

        if self.grid_scan_motor_coordinates is not None:
            # TODO: Add all coordinates!
            if not self.grid_scan_motor_coordinates.use_centring_table:
                maximum_number_of_spots.motor_positions = MotorCoordinates(
                    alignment_y=self.alignment_y_coords[
                        y_coord,
                        x_coord,
                    ],
                    alignment_z=self.alignment_z_coords[
                        y_coord,
                        x_coord,
                    ],
                )

        return maximum_number_of_spots

    def plot_crystal_finder_results(
        self,
        save: bool = False,
        interpolation: str = None,
        plot_centers_of_mass: bool = True,
        filename: str = "crystal_finder_results",
    ) -> tuple[list[CrystalPositions], list[dict[str, int]], MaximumNumberOfSpots]:
        """
        Calculates the center of mass of individual crystals in a loop,
        the location and size of all crystals, and estimates
        the distance between overlapping crystals. Finally these results
        are plotted

        Parameters
        ----------
        save : bool, optional
            If true, we save the image
        interpolation : str, optional
            Interpolation used by plt.imshow(). Could be any of the interpolations
            described in the plt.imshow documentation, by default None
        plot_center_of_mass : bool, optional
            If true, we plot the centers of mass
        filename : str
            Name of the image. The filename is used only if save=True,
            by default crystal_finder_results

        Returns
        -------
        tuple[list[CrystalPositions], list[dict[str, int]]]
            A list containing the centers of mass of all crystals in the loop,
            a list of dictionaries containing information about the locations and sizes
            of all crystals, and a list of dictionaries describing the distance between
            all overlapping crystals in a loop
        """

        (
            list_of_crystal_locations,
            distance_list,
            maximum_number_of_spots_location,
        ) = self.find_crystals_and_overlapping_crystal_distances()

        if list_of_crystal_locations is None or distance_list is None:
            return None, None

        logger.info(f"List of crystal locations: {list_of_crystal_locations}")

        marker_list = [
            ".",
            "+",
            "v",
            "p",
            ">",
            "s",
            "P",
            "D",
            "X",
            "1",
            "2",
            "<",
            "3",
            "4",
            "^",
            "o",
        ]
        golden_ratio = 1.618
        plt.figure(figsize=[7 * golden_ratio, 7])
        c = plt.imshow(self.filtered_array, interpolation=interpolation)
        plt.scatter(
            maximum_number_of_spots_location.pixel_position[0],
            maximum_number_of_spots_location.pixel_position[1],
            marker="s",
            s=200,
            label="Maximum number of spots",
        )
        if plot_centers_of_mass:
            for i, crystal_location in enumerate(list_of_crystal_locations):
                try:
                    plt.scatter(
                        crystal_location.center_of_mass_pixels[0],
                        crystal_location.center_of_mass_pixels[1],
                        label=f"Center of mass: Crystal #{i}",
                        marker=marker_list[i],
                        s=200,
                        color="red",
                    )
                except IndexError:  # we ran out of markers :/
                    plt.scatter(
                        crystal_location.center_of_mass_pixels[0],
                        crystal_location.center_of_mass_pixels[1],
                        label=f"Center of mass: Crystal #{i}",
                        s=200,
                        color="red",
                    )
            plt.legend(labelspacing=1.5)

        for crystal_locations in list_of_crystal_locations:
            self._plot_rectangle_surrounding_crystal(crystal_locations)

        plt.colorbar(c, label="Number of spots")
        if save:
            plt.savefig(filename)
        plt.close()
        return (
            list_of_crystal_locations,
            distance_list,
            maximum_number_of_spots_location,
        )

    def _plot_rectangle_surrounding_crystal(
        self,
        rectangle_coordinates: CrystalPositions,
    ) -> None:
        """
        Plots a rectangle surrounding a crystal

        Parameters
        ----------
        rectangle_coordinates : CrystalPositions
            A CrystalPositions pydantic model obtained from the self._rectangle_coords method

        Returns
        -------
        None
        """
        # top
        x = np.linspace(
            rectangle_coordinates.bottom_left_pixel_coords[0] - 0.5,
            rectangle_coordinates.top_right_pixel_coords[0] + 0.5,
            100,
        )
        z = (rectangle_coordinates.top_right_pixel_coords[1] - 0.5) * np.ones(len(x))
        plt.plot(x, z, color="red", linestyle="--")

        # Bottom
        x = np.linspace(
            rectangle_coordinates.bottom_left_pixel_coords[0] - 0.5,
            rectangle_coordinates.top_right_pixel_coords[0] + 0.5,
            100,
        )
        z = (rectangle_coordinates.bottom_left_pixel_coords[1] + 0.5) * np.ones(len(x))
        plt.plot(x, z, color="red", linestyle="--")

        # Right side
        z = np.linspace(
            rectangle_coordinates.top_right_pixel_coords[1] - 0.5,
            rectangle_coordinates.bottom_left_pixel_coords[1] + 0.5,
            100,
        )
        x = (rectangle_coordinates.top_right_pixel_coords[0] + 0.5) * np.ones(len(x))
        plt.plot(x, z, color="red", linestyle="--")

        # Left side
        z = np.linspace(
            rectangle_coordinates.top_right_pixel_coords[1] - 0.5,
            rectangle_coordinates.bottom_left_pixel_coords[1] + 0.5,
            100,
        )
        x = (rectangle_coordinates.bottom_left_pixel_coords[0] - 0.5) * np.ones(len(x))
        plt.plot(x, z, color="red", linestyle="--")


class CrystalFinder3D:
    """
    Finds the 3D coordinates of multiple crystals in a loop, as well their 3D centers of mass
    based on the edge and flat coordinates of a crystal, which can be obtained
    using the CrystalFinder class.
    """

    def __init__(
        self,
        coords_flat: list[CrystalPositions],
        coords_edge: list[CrystalPositions],
        dist_flat: list[dict],
        dist_edge: list[dict],
    ) -> None:
        """
        Parameters
        ----------
        coords_flat : list[dict]
            The flat coordinates of the crystal obtained from the CrystalFinder class
        coords_edge : list[dict]
            The flat coordinates of the crystal obtained from the CrystalFinder class

        Returns
        -------
        None
        """
        self.coords_flat = coords_flat
        self.coords_edge = coords_edge

        self.dist_flat = dist_flat
        self.dist_edge = dist_edge

    def cube_vertices(self) -> list[tuple[int, int, int]]:
        """
        Calculates the vertices of an array from the flat and edge coordinates.
        These coordinates should be obtained from the CrystalFinder.
        If an index error occurs, it means that are overlapping crystals, in which case
        we use the coordinates of the j-th crystal in replacement of its
        corresponding i-th overlapping crystal to infer the volume.
        However, this won't result in accurate results. TODO: This can be improved!

        Returns
        -------
        list[tuple[int, int, int]]
            A list containing the vertices describing the cube surrounding a crystal
        """
        vertices = []
        for i in range(len(self.coords_flat)):
            try:
                vertices.append(
                    self.vertices_list(self.coords_flat, self.coords_edge, i, i)
                )
            except IndexError:
                for j, dist in enumerate(self.dist_flat):
                    overlapping_index = dist[str(j)]
                    if overlapping_index == i:
                        vertices.append(
                            self.vertices_list(self.coords_flat, self.coords_edge, i, j)
                        )
                        logger.info(f"Crystal {i} is overlapping with crystal {j}")
                        break
        return vertices

    def vertices_list(
        self,
        coords_flat: list[CrystalPositions],
        coords_edge: list[CrystalPositions],
        coords_flat_index: int,
        coords_edge_index: int,
    ):
        vertices_list = [
            (
                coords_flat[coords_flat_index].min_x,
                coords_flat[coords_flat_index].min_y,
                coords_edge[coords_edge_index].min_y,
            ),
            (
                coords_flat[coords_flat_index].min_x,
                coords_flat[coords_flat_index].min_y,
                coords_edge[coords_edge_index].max_y,
            ),
            (
                coords_flat[coords_flat_index].min_x,
                coords_flat[coords_flat_index].max_y,
                coords_edge[coords_edge_index].min_y,
            ),
            (
                coords_flat[coords_flat_index].min_x,
                coords_flat[coords_flat_index].max_y,
                coords_edge[coords_edge_index].max_y,
            ),
            (
                coords_flat[coords_flat_index].max_x,
                coords_flat[coords_flat_index].min_y,
                coords_edge[coords_edge_index].min_y,
            ),
            (
                coords_flat[coords_flat_index].max_x,
                coords_flat[coords_flat_index].min_y,
                coords_edge[coords_edge_index].max_y,
            ),
            (
                coords_flat[coords_flat_index].max_x,
                coords_flat[coords_flat_index].max_y,
                coords_edge[coords_edge_index].min_y,
            ),
            (
                coords_flat[coords_flat_index].max_x,
                coords_flat[coords_flat_index].max_y,
                coords_edge[coords_edge_index].max_y,
            ),
        ]

        return vertices_list

    def crystal_volumes(self) -> list[CrystalVolume]:
        """
        Calculates the crystal volumes in a loop

        Returns
        -------
        list[CrystalVolume]
            A list of CrystalVolume pydantic models
        """
        volume_list = []
        for (flat, edge) in zip(self.coords_flat, self.coords_edge):
            width = flat.width_micrometers
            height = flat.height_micrometers
            depth = edge.width_micrometers
            if int(flat.height_micrometers) != int(edge.height_micrometers):
                logger.info(
                    "The height inferred from the flat and edge scans are "
                    "not equal, something has gone wrong!"
                )
            volume_list.append(
                CrystalVolume(
                    width=width,
                    height=height,
                    depth=depth,
                    volume=width * height * depth,
                )
            )
        return volume_list

    def plot_crystals(
        self,
        plot_centers_of_mass: bool = True,
        save: bool = False,
        filename: str = "crystal_finder_3d_results",
    ) -> list[CrystalVolume]:
        """
        Plots the cubes surrounding crystals based on the edge and flat coordinates found by
        the CrystalFinder.
        FIXME: get the centers of mass for overlapping crystals. At the moment if two
        crystals overlap, we cannot accurately find the centers of mass in 3D (2D works fine),
        and we get an error


        Parameters
        ----------
        plot_centers_of_mass : bool, optional
            If true, plot the centers of mass of each crystal, by default True
        save : bool, optional
            If true, we save the CrystalFinder3D plot, be default False
        filename : str, optional
            Name of the file if save=True, by default crystal_finder_3d_results

        Returns
        -------
        list[CrystalVolume]
            A list of crystal volumes
        """
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")

        vertices = self.cube_vertices()

        for i, z in enumerate(vertices):
            # set vertices connectors
            verts = [
                [z[0], z[1], z[5], z[4]],
                [z[4], z[6], z[7], z[5]],
                [z[7], z[6], z[2], z[3]],
                [z[2], z[0], z[1], z[3]],
                [z[5], z[7], z[3], z[1]],
                [z[0], z[2], z[6], z[4]],
            ]
            # plot sides
            ax.add_collection3d(
                Poly3DCollection(
                    verts,
                    facecolors="blue",
                    linewidths=1,
                    edgecolors="black",
                    alpha=0.1,
                )
            )
            # FIXME: get the centers of mass for overlapping crystals
            if plot_centers_of_mass:
                ax.scatter3D(
                    self.coords_flat[i].center_of_mass_pixels[0],
                    self.coords_flat[i].center_of_mass_pixels[1],
                    self.coords_edge[i].center_of_mass_pixels[1],
                    label=f"CM Crystal {i}",
                    color="r",
                )

        min_lim = min(min(min(vertices)))
        max_lim = max(max(max(vertices)))
        ax.set_xlim3d(min_lim, max_lim)
        ax.set_ylim3d(min_lim, max_lim)
        ax.set_zlim3d(min_lim, max_lim)
        ax.set_xlabel("x")
        ax.set_ylabel("y")
        ax.set_zlabel("z")
        plt.legend()

        if save:
            plt.savefig(filename)

        return self.crystal_volumes()


async def find_crystal_positions(
    redis_connection: redis.StrictRedis,
    id: str,
    grid_scan_id: str,
    threshold: int = 5,
    filename: str = "crystal_finder_results",
) -> tuple[list[CrystalPositions], list[dict[str, int]], npt.NDArray, bytes]:
    """
    Finds the crystal position based on the number of spots obtained from a
    grid_scan using the CrystalFinder class. The number of spots are obtained
    from redis streams, which are generated by the mx - spotfinder in the
    mx - zmq - consumer. The order of the number of spots is assumed to
    correspond to an md3_grid_scan with the parameters:
        invert_direction = True,
        use_fast_mesh_scans = True
    This function is currently used the prefect optical and x ray centering
    workflow
    TODO: Account for all md3 grid scan options.

    Parameters
    ----------
    id: str
        Id of the sample or tray
    grid_scan_id : str
        The grid scan type. Can be either `flat` or `edge` for single loops,
        or the drop location for trays
    raster_grid_coordinates : RasterGridCoordinates
        RasterGridCoordinates pydantic model
    filename: str, optional
        The name of the file used to save the CrystalFinder results if
        self.plot = True, by default crystal_finder_results

    Returns
    -------
    tuple[list[CrystalPositions], list[dict[str, int]], npt.NDArray, bytes]
        1) A list of CrystalPositions pydantic models,
        2) A list of dictionaries describing the distance between all overlapping crystals,
        3) A numpy array containing the numbers of spots.
    """
    raster_grid_coordinates = _get_single_loop_raster_grid_coordinates(
        redis_connection, id, grid_scan_id
    )
    n_rows = raster_grid_coordinates.number_of_rows
    n_cols = raster_grid_coordinates.number_of_columns
    result = []
    number_of_spots_list = []

    number_of_frames = redis_connection.xlen(f"spotfinder_results_{grid_scan_id}:{id}")
    while number_of_frames < n_rows * n_cols:
        # TODO: include a timeout, and notify the user that we lost frames
        # somewhere
        await asyncio.sleep(0.2)
        number_of_frames = redis_connection.xlen(
            f"spotfinder_results_{grid_scan_id}:{id}"
        )
        logger.info(
            f"Expecting {n_rows*n_cols} frames, got {number_of_frames} frames so far"
        )

    last_id = 0
    for _ in range(number_of_frames):
        try:
            spotfinder_results, last_id = _get_spotfinder_results(
                redis_connection, id, grid_scan_id, last_id
            )
            result.append(spotfinder_results)
            number_of_spots_list.append(spotfinder_results.number_of_spots)
        except IndexError:
            pass

    # Reorder array
    number_of_spots_array = (
        np.array(number_of_spots_list).reshape(n_cols, n_rows).transpose()
    )

    crystal_finder = CrystalFinder(
        number_of_spots_array,
        threshold=threshold,
        grid_scan_motor_coordinates=raster_grid_coordinates,
    )
    (
        crystal_locations,
        distance_between_crystals,
        maximum_number_of_spots_location,
    ) = crystal_finder.plot_crystal_finder_results(save=True, filename=filename)

    return (
        crystal_locations,
        distance_between_crystals,
        maximum_number_of_spots_location,
    )


def _get_spotfinder_results(
    redis_connection: redis.StrictRedis,
    id: str,
    grid_scan_id: str,
    redis_streams_id: Union[bytes, int],
) -> tuple[SpotfinderResults, bytes]:
    """
    Gets the spotfinder results from redis streams. The spotfinder results
    are calculated by the mx-hdf5-builder service. The name of the redis key
    follows the format f"spotfinder_results:{id}"

    Parameters
    ----------
    id : str
        The id of the sample or tray
    grid_scan_id : str
        The grid scan type. Can be either `flat` or `edge` for loops,
        or the drop location for trays
    redis_streams_id: Union[bytes, int]
        redis streams topic id of the in bytes or int format

    Returns
    -------
    spotfinder_results, last_id: tuple[SpotfinderResults, bytes]
        A tuple containing SpotfinderResults and the redis streams
        last_idf
    """
    topic = f"spotfinder_results_{grid_scan_id}:{id}"
    response = redis_connection.xread({topic: redis_streams_id}, count=1)

    # Extract key and messages from the response
    _, messages = response[0]

    # Update last_id and store messages data
    last_id, data = messages[0]

    heatmap_coordinate = pickle.loads(data[b"heatmap_coordinate"])

    spotfinder_results = SpotfinderResults(
        type=data[b"type"],
        number_of_spots=data[b"number_of_spots"],
        image_id=data[b"image_id"],
        series_id=data[b"series_id"],
        id=data[b"id"],
        heatmap_coordinate=heatmap_coordinate,
        grid_scan_id=data[b"grid_scan_id"],
    )

    assert (
        id == spotfinder_results.id
    ), "The spotfinder id is different from the queueserver id"
    return spotfinder_results, last_id


def _get_single_loop_raster_grid_coordinates(
    redis_connection: redis.StrictRedis, id: str, grid_scan_id: str
) -> RasterGridCoordinates:
    """Gets the raster grid coordinates generated by the optical centering
    plan from redis.

    Parameters
    ----------
    redis_connection : redis.StrictRedis
        Redis connection
    id : str
        ID of the sample or tray
    grid_scan_id : str
        Grid scan type, could be flat, edge, or None

    Returns
    -------
    RasterGridCoordinates
        The raster grid motor coordinates
    """
    results = pickle.loads(redis_connection.get(f"optical_centering_results:{id}"))
    if grid_scan_id == "flat":
        grid_motor_coordinates = RasterGridCoordinates.parse_obj(
            results["flat_grid_motor_coordinates"]
        )
    elif grid_scan_id == "edge":
        grid_motor_coordinates = RasterGridCoordinates.parse_obj(
            results["edge_grid_motor_coordinates"]
        )
    return grid_motor_coordinates


async def find_crystals_in_tray(
    redis_connection: redis.StrictRedis,
    tray_id: str,
    drop_location: str,
    threshold: int = 5,
    filename: str = "crystal_finder_results",
) -> tuple[list[CrystalPositions], list[dict[str, int]], MaximumNumberOfSpots]:
    """
    Finds the crystal position based on the number of spots obtained from a
    grid_scan using the CrystalFinder class. The number of spots are obtained
    from redis streams, which are generated by the mx - spotfinder in the
    mx - zmq - consumer. The order of the number of spots is assumed to
    correspond to an md3_grid_scan with the parameters:
        invert_direction = True,
        use_fast_mesh_scans = True
    This function is currently used the prefect tray screening workflow
    TODO: Account for all md3 grid scan options.

    Parameters
    ----------
    id: str
        Id of the sample or tray
    grid_scan_id : str
        The grid scan type. Can be either `flat` or `edge` for single loops,
        or the drop location for trays
    raster_grid_coordinates : RasterGridCoordinates
        RasterGridCoordinates pydantic model
    filename: str, optional
        The name of the file used to save the CrystalFinder results if
        self.plot = True, by default crystal_finder_results

    Returns
    -------
    tuple[list[CrystalPositions], list[dict[str, int]], npt.NDArray, bytes]
        1) A list of CrystalPositions pydantic models,
        2) A list of dictionaries describing the distance between all overlapping crystals,
        3) A numpy array containing the numbers of spots.
    """
    redis_key = None
    while redis_key is None:
        redis_key = redis_connection.get(
            f"tray_raster_grid_coordinates_{drop_location}:{tray_id}"
        )
        await asyncio.sleep(1)

    raster_grid_coordinates = RasterGridCoordinates.parse_obj(pickle.loads(redis_key))
    n_rows = raster_grid_coordinates.number_of_rows
    n_cols = raster_grid_coordinates.number_of_columns

    number_of_frames = 0
    while number_of_frames < n_rows * n_cols:
        # TODO: include a timeout, and notify the user that we lost frames
        # somewhere
        number_of_frames = redis_connection.xlen(
            f"spotfinder_results_{drop_location}:{tray_id}"
        )
        logger.info(
            f"Expecting {n_rows*n_cols} frames, got {number_of_frames} frames so far"
        )
        await asyncio.sleep(1)

    last_id = 0
    number_of_spots_array = np.zeros([n_rows, n_cols], dtype=int)
    for _ in range(number_of_frames):
        spotfinder_results, last_id = _get_spotfinder_results(
            redis_connection, tray_id, drop_location, last_id
        )
        coords = spotfinder_results.heatmap_coordinate
        number_of_spots_array[
            (coords[1], coords[0])
        ] = spotfinder_results.number_of_spots

    crystal_finder = CrystalFinder(
        number_of_spots_array,
        threshold=threshold,
        # TODO: Add motor coordinates! We ignore them for now
        grid_scan_motor_coordinates=raster_grid_coordinates,
    )
    (
        crystal_locations,
        distance_between_crystals,
        maximum_number_of_spots_location,
    ) = crystal_finder.plot_crystal_finder_results(save=True, filename=filename)

    return (
        crystal_locations,
        distance_between_crystals,
        maximum_number_of_spots_location,
    )


if __name__ == "__main__":
    path = "/mnt/shares/smd_share/4Mrasterdata/SCOMPMX-273/spotfinder_results"

    # Test crystal finder with random raster grid motor coordinates
    raster_grid_coords = RasterGridCoordinates(
        use_centring_table=True,
        initial_pos_alignment_z=1,
        final_pos_alignment_z=1,
        initial_pos_sample_x=-0.02,
        final_pos_sample_x=-0.1,
        initial_pos_sample_y=0.6,
        final_pos_sample_y=0.7,
        initial_pos_alignment_y=0.01,
        final_pos_alignment_y=0.4,
        center_pos_sample_x=-0.06,
        center_pos_sample_y=0.7,
        width_mm=0.18,
        height_mm=0.42,
        number_of_columns=1,
        number_of_rows=2,
        omega=90,
    )
    # Edge
    flat = np.load(f"{path}/flat.npy")
    # flat = np.rot90(np.append(flat, flat, axis=0), k=1)
    # flat = np.append(flat, flat, axis=0)
    raster_grid_coords.number_of_columns = flat.shape[1]
    raster_grid_coords.number_of_rows = flat.shape[0]

    t = time.perf_counter()
    crystal_finder = CrystalFinder(
        flat, threshold=5, grid_scan_motor_coordinates=raster_grid_coords
    )

    (
        coords_flat,
        distance_flat,
        maximum_number_of_spots_location,
    ) = crystal_finder.plot_crystal_finder_results(save=True, filename="flat")
    print("\nCrystal locations and sizes:\n", coords_flat)
    print("\nDistance between overlapping crystals:\n", distance_flat)
    plt.title("Flat")

    # Flat
    edge = np.load(f"{path}/edge.npy")
    # edge = np.append(edge, edge, axis=1)
    raster_grid_coords.number_of_columns = edge.shape[1]
    raster_grid_coords.number_of_rows = edge.shape[0]
    t = time.perf_counter()
    crystal_finder = CrystalFinder(
        edge, threshold=5, grid_scan_motor_coordinates=raster_grid_coords
    )

    (
        coords_edge,
        distance_edge,
        maximum_number_of_spots_location,
    ) = crystal_finder.plot_crystal_finder_results(save=True, filename="edge")

    print("\nCrystal locations and sizes:\n", coords_edge)
    print("\nDistance between overlapping crystals:\n", distance_edge)
    print("Calculation time (s):", time.perf_counter() - t)
    plt.title("Edge")

    crystal_finder_3d = CrystalFinder3D(
        coords_flat, coords_edge, distance_flat, distance_edge
    )
    crystal_volumes = crystal_finder_3d.plot_crystals(
        plot_centers_of_mass=True, save=True
    )
    print("Crystal volumes:", crystal_volumes)
